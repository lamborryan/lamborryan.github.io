
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>
    
  开源技术 - 追风的蓝宝
  

  </title>
  <meta name="author" content="">
  <meta name="description" content="爱好大数据与开源技术">

  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  
  <link href="asset/css/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  <link href="atom.xml" rel="alternate" title="追风的蓝宝" type="application/atom+xml">
  <script src="asset/js/modernizr-2.0.js"></script>
  <script src="asset/js/jquery.min.js"></script>
  <script src="asset/highlightjs/highlight.pack.js"></script>
  <link href="asset/highlightjs/styles/solarized_light.css" media="screen, projection" rel="stylesheet" type="text/css">
  <script>hljs.initHighlightingOnLoad();</script>

  <style type="text/css">
  .cat-children-p{ padding: 6px 0px;}
  .hljs{background: none;}
  </style>
  <script type="text/javascript">
  var isAddSildbar = true;
  </script>
  <script src="asset/js/octopress.js" type="text/javascript"></script>
</head>
<script type="text/javascript">
//链接新开窗口
function addBlankTargetForLinks () {
  $('a[href^="http"]').each(function(){
      $(this).attr('target', '_blank');
  });
}
$(document).ready(function(event) {
  addBlankTargetForLinks();
});
</script>
<body   >
  <header role="banner"><hgroup>
  <h1><a href="index.html">追风的蓝宝</a></h1>
  
    <h2>爱好大数据与开源技术</h2>
  
</hgroup>

</header>
  <nav role="navigation"><ul class="subscription" data-subscription="rss">
  <li><a href="atom.xml" rel="subscribe-rss" title="subscribe via RSS">RSS</a></li>
  
</ul>
  
<form action="http://google.com/search" method="get">
  <fieldset role="search">
    <input type="hidden" name="q" value="site:www.lamborryan.com" />
    <input class="search" type="text" name="q" results="0" placeholder="Search"/>
  </fieldset>
</form>
  
<ul class="main-navigation">

  <li id=""><a target="_self" href="index.html">Home</a></li>

  <li id=""><a target="_self" href="archives.html">Archives</a></li>

  <li id=""><a target="_self" href="about.html">About</a></li>

</ul>

</nav>
  <div id="main">
    <div id="content"> 
<div class="blog-index">

	<article>
		 <header>
		  	<h1 class="entry-title"><a href="15155074940397.html">Solr4.8.0源码分析汇总</a></h1>
			<p class="meta"><time datetime="2018-01-09T22:18:14+08:00" 
			pubdate data-updated="true">2018/1/9</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<ul>
<li>
<a href="#toc_0">简介</a>
</li>
<li>
<a href="#toc_1">目录</a>
</li>
<li>
<a href="#toc_2">总结</a>
</li>
</ul>


<h2 id="toc_0">简介</h2>

<p>由于第一份工作是关于搜索引擎的, 所以当初也痴迷过Solr, 也花了两年时间研究了Solr.</p>

<p>因此以前在<a href="http://www.cnblogs.com/rcfeng/">博客园</a>写了不少关于Solr/SolrCloud的博客, 文章有点多就不一一迁移过来了, 就在这里建个导航。</p>



		</div>

		 
		 <footer>
      	<a rel="full-article" href="15155074940397.html#more">read more &rarr;</a>
    	</footer>
    	

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="15155073098227.html">Gobblin系列(8)之Extractor源码分析</a></h1>
			<p class="meta"><time datetime="2018-01-09T22:15:09+08:00" 
			pubdate data-updated="true">2018/1/9</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<ul>
<li>
<a href="#toc_0">一. 简介</a>
</li>
<li>
<a href="#toc_1">二. MysqlExtractor的类继承关系。</a>
</li>
<li>
<a href="#toc_2">三. Extractor接口</a>
</li>
<li>
<a href="#toc_3">四: QueryBasedExtractor</a>
</li>
<li>
<a href="#toc_4">五: JdbcExtractor 和 MysqlExtractor</a>
</li>
<li>
<a href="#toc_5">六: 总结</a>
<ul>
<li>
<a href="#toc_6">本文完</a>
</li>
</ul>
</li>
</ul>


<h2 id="toc_0">一. 简介</h2>

<p>Extractor相比Source来说就简单多了, 因为Source不但要考虑当前job的WorkUnits, 还要考虑前一个Job的WorkUnits. 相比之下Extractor的服务对象就单个WorkUnits, 要实现的功能也无非就是根据low water mark和high water mark从数据源那里获取数据。</p>

<p>因此本文主要介绍Extractor如何实现上述描述的功能。目前Gobblin支持且常用的Extractor有MysqlExtractor, KafkaSimpleSource等等, 本文依然以MysqlExtractor为例来介绍Extractor。</p>



		</div>

		 
		 <footer>
      	<a rel="full-article" href="15155073098227.html#more">read more &rarr;</a>
    	</footer>
    	

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="15155071664887.html">Gobblin系列(7)之Source源码分析</a></h1>
			<p class="meta"><time datetime="2018-01-09T22:12:46+08:00" 
			pubdate data-updated="true">2018/1/9</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<ul>
<li>
<a href="#toc_0">一.简介</a>
</li>
<li>
<a href="#toc_1">三.AbstractSource</a>
</li>
<li>
<a href="#toc_2">四.QueryBasedSource</a>
<ul>
<li>
<a href="#toc_3">4.1. getLatestWatermarkFromMetadata</a>
</li>
<li>
<a href="#toc_4">4.2. Partitioner</a>
</li>
<li>
<a href="#toc_5">4.3. 总结</a>
</li>
</ul>
</li>
<li>
<a href="#toc_6">五.MysqlSource</a>
</li>
<li>
<a href="#toc_7">总结</a>
</li>
<li>
<a href="#toc_8">本文完</a>
</li>
</ul>


<h2 id="toc_0">一.简介</h2>

<p>Source在整个Gobblin任务流中负责以下三点:</p>

<ol>
<li>对数据源进行预切分获取<code>WorkUnits</code>。所谓预切分即是在不知道数据源是啥样的前提下, 划分好数据。</li>
<li>为每一个<code>task</code>生成一个<code>extractor</code>, 一般情况下一个<code>task</code>对应一个<code>WorkUnit</code>(当然也存在多对多的情况), 从而实现对数据的摄取。</li>
<li>提供<code>shutdown</code>处理机制, 即在job完成时候gobblin会回调<code>shutdown</code>函数, 我们可以在这里进行相应的逻辑处理。</li>
</ol>

<p>这些功能都是通过Source接口实现的。</p>



		</div>

		 
		 <footer>
      	<a rel="full-article" href="15155071664887.html#more">read more &rarr;</a>
    	</footer>
    	

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="15155068855798.html">Gobblin系列(6)之State</a></h1>
			<p class="meta"><time datetime="2018-01-09T22:08:05+08:00" 
			pubdate data-updated="true">2018/1/9</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<ul>
<li>
<a href="#toc_0">一. 简介</a>
</li>
<li>
<a href="#toc_1">二. SourceState, JobState, DatasetState</a>
<ul>
<li>
<a href="#toc_2">2.1.SourceState</a>
</li>
<li>
<a href="#toc_3">2.2.JobState</a>
</li>
<li>
<a href="#toc_4">2.3.DatasetState</a>
</li>
</ul>
</li>
<li>
<a href="#toc_5">三. WorkUnit, MutliWorkUnit</a>
<ul>
<li>
<a href="#toc_6">3.1.WorkUnit</a>
</li>
<li>
<a href="#toc_7">3.2.MutliWorkUnit</a>
</li>
</ul>
</li>
<li>
<a href="#toc_8">四. WorkUnitState, TaskState</a>
<ul>
<li>
<a href="#toc_9">4.1.WorkUnitState</a>
</li>
<li>
<a href="#toc_10">4.2.TaskState</a>
</li>
</ul>
</li>
<li>
<a href="#toc_11">五. Extract</a>
</li>
<li>
<a href="#toc_12">六. 运行过程转换</a>
</li>
<li>
<a href="#toc_13">七. 总结</a>
</li>
</ul>


<h2 id="toc_0">一. 简介</h2>

<p>Gobblin实在是有太多的state了, 比如SourceState, JobState, DatasetState, WorkUnit等等. 而这些State又跟整个Gobblin的各个阶段密切联系, 所以我独立出一篇文章来理顺下这些State。</p>



		</div>

		 
		 <footer>
      	<a rel="full-article" href="15155068855798.html#more">read more &rarr;</a>
    	</footer>
    	

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="15155067914960.html">Gobblin系列(5)之Writer源码分析</a></h1>
			<p class="meta"><time datetime="2018-01-09T22:06:31+08:00" 
			pubdate data-updated="true">2018/1/9</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<ul>
<li>
<a href="#toc_0">简介</a>
</li>
<li>
<a href="#toc_1">流程简述</a>
</li>
<li>
<a href="#toc_2">PartitionedDataWriter</a>
<ul>
<li>
<ul>
<li>
<a href="#toc_3">PartitionedDataWriter的初始化</a>
</li>
<li>
<a href="#toc_4">PartitionedDataWriter的基类</a>
</li>
<li>
<a href="#toc_5">PartitionedDataWriter的具体实现</a>
</li>
</ul>
</li>
</ul>
</li>
<li>
<a href="#toc_6">partition</a>
</li>
<li>
<a href="#toc_7">DataWriter</a>
</li>
<li>
<a href="#toc_8">Publiser</a>
</li>
<li>
<a href="#toc_9">总结</a>
</li>
</ul>


<h2 id="toc_0">简介</h2>

<p>Gobblin的writer功能还是很强大的, 该Stage负责将record写入临时文件中。由于项目的需要, 要求把每天的kafka日志按照日期按天输出到不同的目录。所以花了一天时间研究了Writer的源码和流程。</p>



		</div>

		 
		 <footer>
      	<a rel="full-article" href="15155067914960.html#more">read more &rarr;</a>
    	</footer>
    	

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="15155066323075.html">Gobblin系列(4)之Runtime初探</a></h1>
			<p class="meta"><time datetime="2018-01-09T22:03:52+08:00" 
			pubdate data-updated="true">2018/1/9</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<ul>
<li>
<a href="#toc_0">简介</a>
</li>
<li>
<a href="#toc_1">工作流</a>
<ul>
<li>
<ul>
<li>
<a href="#toc_2">commit/publiser 和 persist</a>
</li>
</ul>
</li>
</ul>
</li>
<li>
<a href="#toc_3">任务流</a>
<ul>
<li>
<ul>
<li>
<a href="#toc_4">Task逻辑</a>
</li>
<li>
<a href="#toc_5">Fork 逻辑</a>
</li>
</ul>
</li>
</ul>
</li>
<li>
<a href="#toc_6">总结</a>
</li>
</ul>


<h2 id="toc_0">简介</h2>

<p>Gobblin有两个重要的包即Gobblin-core和Gobblin-runtime, 前者实现了丰富的模块组件, 后者实现了完整的运行机制, 如此构成了Gobblin的高可扩展性的特点。</p>

<p>作为Gobblin的内核, Gobblin-runtime实现了Gobblin的工作流程和任务流程。本文名为Runtime初探, 主要研究目的就是通过Gobblin-runtime来了解Gobblin的运行逻辑, 便于后续对Gobblin的灵活开发。</p>

<p>在前文<a href="http://lamborryan.github.io/gobblin-first-exploration/">《Gobblin系列一之初探》</a>中提到了Gobblin具有工作流和任务流的概念。那么本文就分为工作流和任务流两块来介绍。</p>



		</div>

		 
		 <footer>
      	<a rel="full-article" href="15155066323075.html#more">read more &rarr;</a>
    	</footer>
    	

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="15155065803565.html">Gobblin系列(3)之Azkaban Schedule</a></h1>
			<p class="meta"><time datetime="2018-01-09T22:03:00+08:00" 
			pubdate data-updated="true">2018/1/9</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<ul>
<li>
<a href="#toc_0">前言</a>
</li>
<li>
<a href="#toc_1">配置过程</a>
<ul>
<li>
<a href="#toc_2">注意事项</a>
</li>
<li>
<a href="#toc_3">安装Azkaban jobtype plugin</a>
</li>
<li>
<a href="#toc_4">Gobblin Job</a>
<ul>
<li>
<a href="#toc_5">创建Gobblin的azkaban Job</a>
</li>
<li>
<a href="#toc_6">创建gobblin job</a>
</li>
</ul>
</li>
</ul>
</li>
<li>
<a href="#toc_7">总结</a>
</li>
</ul>


<h2 id="toc_0">前言</h2>

<p>Gobblin支持三种Schedule即Quartz, Azkaban, Oozie, 默认是采用Quartz. 由于项目的工作流schedule已经采用Azkaban, 所以要将Gobblin Task配置到Azkaban. 但是没相到以为分分钟就能搞定的结果花了我整整一天的时间, 主要问题还是因为Gobblin的资料的匮乏, 在这实现过程中我查阅了Gobblin，Azkaban 和Azkaban-jobtype plugin的源码, 可见繁琐程度. 本文将描述怎么配置Gobblin-Azkaban，并结合主要的代码流程。之所以采用azkaban, 主要因为azkaban使用简单，能有效的进行工作流依赖管理。</p>



		</div>

		 
		 <footer>
      	<a rel="full-article" href="15155065803565.html#more">read more &rarr;</a>
    	</footer>
    	

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="15155064360093.html">Gobblin系列(2)之History Store 和 Admin Server</a></h1>
			<p class="meta"><time datetime="2018-01-09T22:00:36+08:00" 
			pubdate data-updated="true">2018/1/9</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<ul>
<li>
<a href="#toc_0">简介</a>
</li>
<li>
<a href="#toc_1">History Store</a>
</li>
<li>
<a href="#toc_2">Admin Server</a>
<ul>
<li>
<a href="#toc_3">Web Ui</a>
</li>
<li>
<a href="#toc_4">client</a>
</li>
</ul>
</li>
<li>
<a href="#toc_5">总结</a>
<ul>
<li>
<a href="#toc_6">展示所有的job(相同的job只显示一个)</a>
</li>
<li>
<a href="#toc_7">展示job的所有历史记录</a>
</li>
<li>
<a href="#toc_8">展示某个job实例的detail信息, 可查看task, properties[View Job Properties]和metrix[View Metrics]</a>
</li>
</ul>
</li>
</ul>


<h2 id="toc_0">简介</h2>

<p>在阅读Gobblin的时候突然发现Gobblin其实是自带一个Admin Server以及History Store来存放历史的job运行数据, 所以也就研究了下这块内容。 这也反应了Gobblin的一个缺点即文档和资料的缺乏, 不过还好有源码。</p>



		</div>

		 
		 <footer>
      	<a rel="full-article" href="15155064360093.html#more">read more &rarr;</a>
    	</footer>
    	

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="15155061559657.html">Gobblin系列(1)一之初探</a></h1>
			<p class="meta"><time datetime="2018-01-09T21:55:55+08:00" 
			pubdate data-updated="true">2018/1/9</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<ul>
<li>
<a href="#toc_0">简介</a>
</li>
<li>
<a href="#toc_1">框架</a>
</li>
<li>
<a href="#toc_2">工作流</a>
</li>
<li>
<a href="#toc_3">任务组成</a>
<ul>
<li>
<a href="#toc_4">Source and Extractor</a>
</li>
<li>
<a href="#toc_5">Converter</a>
</li>
<li>
<a href="#toc_6">Quality Checker</a>
</li>
<li>
<a href="#toc_7">Fork Operator</a>
</li>
<li>
<a href="#toc_8">Data Writer</a>
</li>
<li>
<a href="#toc_9">Data Publisher</a>
</li>
</ul>
</li>
<li>
<a href="#toc_10">任务流</a>
</li>
<li>
<a href="#toc_11">状态管理</a>
</li>
<li>
<a href="#toc_12">失败处理</a>
</li>
<li>
<a href="#toc_13">工作调度</a>
</li>
<li>
<a href="#toc_14">总结</a>
</li>
</ul>


<hr/>

<p>由于需要从kafka批量把日志dump到hdfs上，所以我们使用了linkin的Gobblin工具。Gobblin目前还处于开发阶段，资料比较少，文档介绍的也不是很详细，要使用他只能去阅读源码。因此我打算通过一系列的Gobblin的文章来记录下我的学习使用心得。</p>

<p>本文主要初步介绍Gobblin的基础框架, 主要内容来自<a href="https://github.com/linkedin/gobblin/wiki/Gobblin-Architecture">《官方文档》</a><br/>
, 然后在后续文章中展开介绍。</p>

<p>本人使用的Gobblin版本是0.6.2</p>



		</div>

		 
		 <footer>
      	<a rel="full-article" href="15155061559657.html#more">read more &rarr;</a>
    	</footer>
    	

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="15154238312203.html">JavaCC的使用总结</a></h1>
			<p class="meta"><time datetime="2018-01-08T23:03:51+08:00" 
			pubdate data-updated="true">2018/1/8</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<ul>
<li>
<a href="#toc_0">1.安装</a>
</li>
<li>
<a href="#toc_1">2.文件格式</a>
<ul>
<li>
<ul>
<li>
<a href="#toc_2">2.1Options部分</a>
</li>
<li>
<a href="#toc_3">2.2分析器类的声明</a>
</li>
<li>
<a href="#toc_4">2.3词法规则定义</a>
<ul>
<li>
<a href="#toc_5">1.SKIP用来说明被忽略的串, 比如碰到以下字符就跳过。</a>
</li>
<li>
<a href="#toc_6">2.TOKEN，用来说明在词法层次上识别的token，比如解析到字母就归为ID这个Token，解析到字母就归属于NUM这个TOKEN。</a>
</li>
<li>
<a href="#toc_7">3.语法规则</a>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>
<a href="#toc_8">3.Lookahead</a>
<ul>
<li>
<a href="#toc_9">3.1 什么是Lookahead</a>
</li>
<li>
<a href="#toc_10">3.2 语法解析器的选择顺序</a>
</li>
<li>
<a href="#toc_11">3.3 怎么使用lookahed</a>
<ul>
<li>
<ul>
<li>
<a href="#toc_12">Lookahead的一般模式</a>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>
<a href="#toc_13">4.总结</a>
</li>
<li>
<a href="#toc_14">5. 参考文献</a>
<ul>
<li>
<ul>
<li>
<a href="#toc_15">本文完。</a>
</li>
</ul>
</li>
</ul>
</li>
</ul>


<hr/>

<p>最近项目SQL解析模块用到Apache Calcite了，由于需要自己定义一些语法，因此花了一段时间研究了其中的JavaCC，本文全当是笔记免得以后忘记。</p>



		</div>

		 
		 <footer>
      	<a rel="full-article" href="15154238312203.html#more">read more &rarr;</a>
    	</footer>
    	

	</article>
  
	<div class="pagination">
	
<a href="archives.html">Blog Archives</a>
	 
	    
	</div>
</div>
 <aside class="sidebar"> 

	<section>
	  <h1>Categories</h1>
	  <ul id="recent_posts">
	  
	      <li class="post">
	        <a href="%E6%95%B0%E4%BB%93%E5%BB%BA%E6%A8%A1.html"><strong>数仓建模&nbsp;(5)</strong></a>
	         <p class="cat-children-p"> 
	        
	        	<a href="StarSchema%E7%AC%94%E8%AE%B0.html">StarSchema笔记&nbsp;(4)</a>&nbsp;&nbsp;
	        
	        	<a href="Data%20Vault.html">Data Vault&nbsp;(1)</a>&nbsp;&nbsp;
	        
	         </p> 
	      </li>
	  
	      <li class="post">
	        <a href="%E5%BC%80%E6%BA%90%E6%8A%80%E6%9C%AF.html"><strong>开源技术&nbsp;(10)</strong></a>
	         <p class="cat-children-p"> 
	        
	        	<a href="Apache%20Calcite.html">Apache Calcite&nbsp;(1)</a>&nbsp;&nbsp;
	        
	        	<a href="Gobblin.html">Gobblin&nbsp;(8)</a>&nbsp;&nbsp;
	        
	        	<a href="Solr.html">Solr&nbsp;(1)</a>&nbsp;&nbsp;
	        
	         </p> 
	      </li>
	   
	  </ul>
	</section>
	<section>
	  <h1>Recent Posts</h1>
	  <ul id="recent_posts">
	  
	      
		      <li class="post">
		        <a href="15155074940397.html">Solr4.8.0源码分析汇总</a>
		      </li>
	     
	  
	      
		      <li class="post">
		        <a href="15155073098227.html">Gobblin系列(8)之Extractor源码分析</a>
		      </li>
	     
	  
	      
		      <li class="post">
		        <a href="15155071664887.html">Gobblin系列(7)之Source源码分析</a>
		      </li>
	     
	  
	      
		      <li class="post">
		        <a href="15155068855798.html">Gobblin系列(6)之State</a>
		      </li>
	     
	  
	      
		      <li class="post">
		        <a href="15155067914960.html">Gobblin系列(5)之Writer源码分析</a>
		      </li>
	     
	  
	      
	  
	      
	  
	      
	  
	      
	  
	      
	  
	      
	  
	      
	  
	      
	  
	      
	  
	      
	   
	  </ul>
	</section>
	
</aside> </div></div>
  <footer role="contentinfo"><p>
  Copyright &copy; 2014 -  -
  <span class="credit">Powered by <a target="_blank" href="http://www.mweb.im">MWeb</a> &nbsp;&nbsp; Theme by <a href="http://octopress.org">Octopress</a></span>
</p>

</footer>

  
    




</body>
</html>